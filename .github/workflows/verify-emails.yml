name: Verify Emails

on:
  workflow_dispatch:
    inputs:
      csv_url:
        description: 'URL to CSV file (or leave empty to use repo file)'
        required: false
        default: ''

jobs:
  verify:
    runs-on: ubuntu-latest
    timeout-minutes: 60

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v6
        with:
          python-version: '3.11'

      - name: Install dependencies
        run: |
          pip install dnspython aiohttp

      - name: Run email verification
        run: |
          python3 << 'PYTHON_SCRIPT'
          import smtplib
          import socket
          import dns.resolver
          import csv
          import json
          import time
          import random
          import urllib.request
          import urllib.parse
          import re
          from typing import Optional, List, Tuple
          from datetime import datetime

          # Nickname mappings
          NICKNAME_MAP = {
              'thomas': ['tom', 'tommy', 'thom'],
              'william': ['will', 'bill', 'billy', 'liam'],
              'robert': ['rob', 'bob', 'bobby', 'bert'],
              'michael': ['mike', 'mick', 'mikey'],
              'richard': ['rick', 'rich', 'dick', 'ricky'],
              'james': ['jim', 'jimmy', 'jamie'],
              'david': ['dave', 'davey'],
              'christopher': ['chris', 'topher', 'kit'],
              'daniel': ['dan', 'danny'],
              'matthew': ['matt', 'matty'],
              'anthony': ['tony', 'ant'],
              'joseph': ['joe', 'joey'],
              'charles': ['charlie', 'chuck', 'chas'],
              'steven': ['steve', 'stevie'],
              'stephen': ['steve', 'stevie'],
              'edward': ['ed', 'eddie', 'ted', 'teddy'],
              'andrew': ['andy', 'drew'],
              'benjamin': ['ben', 'benny', 'benji'],
              'nicholas': ['nick', 'nicky'],
              'timothy': ['tim', 'timmy'],
              'jonathan': ['jon', 'johnny'],
              'katherine': ['kate', 'kathy', 'katie', 'kat'],
              'elizabeth': ['liz', 'beth', 'betty', 'eliza'],
              'jennifer': ['jen', 'jenny', 'jenn'],
              'margaret': ['maggie', 'meg', 'peggy'],
              'patricia': ['pat', 'patty', 'trish'],
              'susan': ['sue', 'susie', 'suzy'],
              'jessica': ['jess', 'jessie'],
              'samantha': ['sam', 'sammy'],
              'alexander': ['alex', 'xander'],
              'alexandra': ['alex', 'lexi', 'ali'],
              'zachary': ['zach', 'zack'],
              'nathan': ['nate'],
              'jacob': ['jake'],
              'joshua': ['josh'],
              'gregory': ['greg'],
              'phillip': ['phil'],
              'lawrence': ['larry'],
              'donald': ['don', 'donny'],
              'gerald': ['gerry', 'jerry'],
              'patrick': ['pat', 'paddy'],
              'samuel': ['sam', 'sammy'],
              'ronald': ['ron', 'ronny'],
              'douglas': ['doug'],
              'kenneth': ['ken', 'kenny'],
              'raymond': ['ray'],
              'rebecca': ['becky', 'becca'],
              'catherine': ['cathy', 'cat', 'kate'],
              'melissa': ['mel', 'missy'],
              'amanda': ['mandy'],
              'theodore': ['ted', 'teddy', 'theo'],
              'frederick': ['fred', 'freddy', 'rick'],
              'maximilian': ['max'],
              'nathaniel': ['nate', 'nat'],
          }

          # Known company domains
          KNOWN_DOMAINS = {
              'dolby': 'dolby.com',
              'dolby laboratories': 'dolby.com',
              'google': 'google.com',
              'microsoft': 'microsoft.com',
              'apple': 'apple.com',
              'amazon': 'amazon.com',
              'meta': 'meta.com',
              'facebook': 'fb.com',
              'netflix': 'netflix.com',
              'salesforce': 'salesforce.com',
              'adobe': 'adobe.com',
              'spotify': 'spotify.com',
              'uber': 'uber.com',
              'airbnb': 'airbnb.com',
              'stripe': 'stripe.com',
              'slack': 'slack.com',
              'dropbox': 'dropbox.com',
              'linkedin': 'linkedin.com',
              'paypal': 'paypal.com',
              'shopify': 'shopify.com',
          }

          CATCHALL_DOMAINS = {
              'gmail.com', 'googlemail.com', 'yahoo.com', 'yahoo.co.uk',
              'outlook.com', 'hotmail.com', 'live.com', 'msn.com',
              'icloud.com', 'me.com', 'mac.com', 'aol.com',
              'protonmail.com', 'proton.me',
          }

          def search_github_for_email(first_name: str, last_name: str, domain: str) -> Optional[str]:
              """Search GitHub for email addresses matching name + domain."""
              if not first_name or not last_name or not domain:
                  return None

              variants = [first_name.lower()]
              if first_name.lower() in NICKNAME_MAP:
                  variants.extend(NICKNAME_MAP[first_name.lower()])
              for full, nicks in NICKNAME_MAP.items():
                  if first_name.lower() in nicks:
                      variants.append(full)

              headers = {
                  'Accept': 'application/vnd.github+json',
                  'User-Agent': 'EmailVerifier/1.0'
              }

              # Method 1: Search GitHub users by name
              for variant in variants[:3]:
                  try:
                      query = urllib.parse.quote(f"{variant} {last_name}")
                      url = f"https://api.github.com/search/users?q={query}&per_page=5"
                      req = urllib.request.Request(url, headers=headers)
                      with urllib.request.urlopen(req, timeout=10) as resp:
                          data = json.loads(resp.read().decode())
                          for user in data.get('items', []):
                              login = user.get('login', '')
                              # Get user details for email
                              user_url = f"https://api.github.com/users/{login}"
                              user_req = urllib.request.Request(user_url, headers=headers)
                              with urllib.request.urlopen(user_req, timeout=10) as user_resp:
                                  user_data = json.loads(user_resp.read().decode())
                                  email = user_data.get('email', '')
                                  if email and domain in email.lower():
                                      print(f"  [GITHUB-USER] Found: {email}")
                                      return email
                  except Exception as e:
                      pass
                  time.sleep(0.3)

              # Method 2: Search code for email patterns
              for variant in variants[:3]:
                  patterns_to_try = [
                      f"{variant}.{last_name.lower()}@{domain}",
                      f"{variant[0]}.{last_name.lower()}@{domain}",
                      f"{variant}{last_name.lower()}@{domain}",
                  ]
                  for email_pattern in patterns_to_try:
                      try:
                          query = urllib.parse.quote(email_pattern)
                          url = f"https://api.github.com/search/code?q={query}&per_page=3"
                          req = urllib.request.Request(url, headers=headers)
                          with urllib.request.urlopen(req, timeout=10) as resp:
                              data = json.loads(resp.read().decode())
                              if data.get('total_count', 0) > 0:
                                  print(f"  [GITHUB-CODE] Found pattern: {email_pattern}")
                                  return email_pattern
                      except Exception as e:
                          pass
                      time.sleep(0.3)

              return None

          def search_company_website(first_name: str, last_name: str, domain: str) -> Optional[str]:
              """Search company website team/about pages for email."""
              if not domain:
                  return None

              variants = [first_name.lower()]
              if first_name.lower() in NICKNAME_MAP:
                  variants.extend(NICKNAME_MAP[first_name.lower()])

              # Common team page URLs
              pages = [
                  f"https://{domain}/about",
                  f"https://{domain}/team",
                  f"https://{domain}/about-us",
                  f"https://{domain}/contact",
                  f"https://www.{domain}/about",
                  f"https://www.{domain}/team",
              ]

              email_pattern = re.compile(r'[a-zA-Z0-9._%+-]+@' + re.escape(domain), re.IGNORECASE)

              for page_url in pages[:4]:  # Limit requests
                  try:
                      req = urllib.request.Request(page_url, headers={
                          'User-Agent': 'Mozilla/5.0 (compatible; EmailVerifier/1.0)'
                      })
                      with urllib.request.urlopen(req, timeout=5) as resp:
                          content = resp.read().decode('utf-8', errors='ignore')
                          emails = email_pattern.findall(content)
                          for email in emails:
                              local = email.split('@')[0].lower()
                              for variant in variants:
                                  if variant in local and last_name.lower() in local:
                                      print(f"  [WEB] Found: {email}")
                                      return email
                  except:
                      pass
                  time.sleep(0.2)

              return None

          def get_name_variants(first_name: str) -> List[str]:
              if not first_name:
                  return []
              name = first_name.lower().strip()
              variants = [name]
              if name in NICKNAME_MAP:
                  variants.extend(NICKNAME_MAP[name])
              for full, nicks in NICKNAME_MAP.items():
                  if name in nicks and full not in variants:
                      variants.append(full)
              if name:
                  variants.append(name[0])
              return list(dict.fromkeys(variants))

          def generate_patterns(first_name: str, last_name: str, domain: str) -> List[str]:
              if not first_name or not last_name or not domain:
                  return []
              variants = get_name_variants(first_name)
              last = last_name.lower().strip()
              patterns = []
              for first in variants[:5]:  # Limit variants
                  patterns.extend([
                      f"{first}.{last}@{domain}",
                      f"{first}{last}@{domain}",
                      f"{first[0]}{last}@{domain}",
                      f"{first[0]}.{last}@{domain}",
                      f"{first}_{last}@{domain}",
                      f"{last}.{first}@{domain}",
                      f"{last}{first[0]}@{domain}",
                  ])
              return list(dict.fromkeys(patterns))[:20]

          def guess_domain(company: str) -> Optional[str]:
              if not company:
                  return None
              company_lower = company.lower().strip()
              if company_lower in KNOWN_DOMAINS:
                  return KNOWN_DOMAINS[company_lower]
              domain = company_lower
              for suffix in ['inc', 'llc', 'ltd', 'corp', 'co', 'company', 'corporation', 'group', 'holdings', 'technologies', 'labs', 'laboratories']:
                  domain = domain.replace(f' {suffix}', '').replace(f' {suffix}.', '')
              domain = ''.join(c for c in domain if c.isalnum())
              return f"{domain}.com" if len(domain) >= 2 else None

          def get_mx_host(domain: str) -> Optional[str]:
              try:
                  resolver = dns.resolver.Resolver()
                  resolver.timeout = 5
                  resolver.lifetime = 5
                  resolver.nameservers = ['8.8.8.8', '1.1.1.1']
                  answers = resolver.resolve(domain, 'MX')
                  mx_records = sorted(answers, key=lambda x: x.preference)
                  return str(mx_records[0].exchange).rstrip('.')
              except:
                  return None

          def check_catchall(domain: str, mx_host: str) -> Tuple[bool, bool]:
              """Returns (is_catchall, could_connect)"""
              random_email = f"nonexistent{random.randint(10000,99999)}@{domain}"
              try:
                  smtp = smtplib.SMTP(timeout=10)
                  smtp.connect(mx_host, 25)
                  smtp.ehlo('mail.verification.test')
                  # Try null sender first (RFC 5321 compliant for verification)
                  mail_code, _ = smtp.mail('')
                  if mail_code != 250:
                      # Try postmaster which servers should accept
                      smtp.rset()
                      mail_code, _ = smtp.mail(f'postmaster@{domain}')
                  if mail_code != 250:
                      print(f"  [DEBUG] Catch-all MAIL FROM rejected - server blocks verification")
                      smtp.quit()
                      return False, False  # Can't determine, server blocks
                  code, _ = smtp.rcpt(random_email)
                  smtp.quit()
                  print(f"  [DEBUG] Catch-all test ({random_email}) -> code {code}")
                  return code == 250, True
              except Exception as e:
                  print(f"  [DEBUG] Catch-all test error: {e}")
                  return False, False

          def verify_email(email: str, mx_host: str) -> Tuple[bool, int, str]:
              try:
                  smtp = smtplib.SMTP(timeout=10)
                  smtp.connect(mx_host, 25)
                  smtp.ehlo('mail.verification.test')
                  # Try null sender (RFC 5321 for bounce/verification)
                  mail_code, mail_msg = smtp.mail('')
                  if mail_code != 250:
                      smtp.rset()
                      mail_code, mail_msg = smtp.mail(f'postmaster@{email.split("@")[1]}')
                  if mail_code != 250:
                      smtp.quit()
                      return False, mail_code, f'MAIL rejected (server blocks verification)'
                  code, msg = smtp.rcpt(email)
                  smtp.quit()
                  msg_str = msg.decode() if isinstance(msg, bytes) else str(msg)
                  return code == 250, code, msg_str
              except Exception as e:
                  return False, 0, str(e)

          def verify_patterns(patterns: List[str], domain: str) -> Tuple[Optional[str], str, str]:
              print(f"  [DEBUG] Patterns to test: {patterns[:5]}...")

              if domain.lower() in CATCHALL_DOMAINS:
                  print(f"  [DEBUG] Known catch-all domain")
                  return patterns[0] if patterns else None, 'catchall', 'Known catch-all domain'

              mx_host = get_mx_host(domain)
              print(f"  [DEBUG] MX host for {domain}: {mx_host}")
              if not mx_host:
                  return patterns[0] if patterns else None, 'no_mx', 'No MX record found'

              # Check if catch-all
              print(f"  [DEBUG] Testing catch-all...")
              is_catchall, could_connect = check_catchall(domain, mx_host)
              print(f"  [DEBUG] Catch-all result: {is_catchall}, could_connect: {could_connect}")

              if not could_connect:
                  # Server blocks verification - return best pattern with medium confidence
                  return patterns[0] if patterns else None, 'unverifiable', 'Server blocks SMTP verification'

              if is_catchall:
                  return patterns[0] if patterns else None, 'catchall', 'Domain accepts all emails'

              # Test each pattern
              print(f"  [DEBUG] Testing {len(patterns)} patterns via SMTP...")
              tested_results = []
              for i, pattern in enumerate(patterns):
                  time.sleep(0.3)  # Rate limit
                  valid, code, msg = verify_email(pattern, mx_host)
                  tested_results.append((pattern, code, msg[:50] if msg else ''))
                  print(f"  [DEBUG] {i+1}. {pattern} -> {code} {'VALID!' if valid else msg[:40]}")
                  if valid:
                      return pattern, 'verified', f'SMTP verified (code {code})'

              # Log all results for debugging
              print(f"  [DEBUG] All {len(tested_results)} patterns failed verification")
              return patterns[0] if patterns else None, 'unverified', 'No pattern verified'

          def process_contact(row: dict) -> dict:
              first_name = row.get('First Name', row.get('first_name', ''))
              last_name = row.get('Last Name', row.get('last_name', ''))
              company = row.get('Company', row.get('company', ''))

              domain = guess_domain(company)
              if not domain:
                  return {**row, 'email': '', 'status': 'no_domain', 'confidence': 'low'}

              # Step 1: Try GitHub search first (finds REAL emails)
              print(f"  [STEP 1] Searching GitHub for {first_name} {last_name} @ {domain}...")
              github_email = search_github_for_email(first_name, last_name, domain)
              if github_email:
                  return {
                      **row,
                      'email': github_email,
                      'domain': domain,
                      'status': 'github_found',
                      'message': 'Found in GitHub',
                      'confidence': 'high',
                      'patterns_tried': 0
                  }

              # Step 1b: Try company website search
              print(f"  [STEP 1b] Searching company website...")
              web_email = search_company_website(first_name, last_name, domain)
              if web_email:
                  return {
                      **row,
                      'email': web_email,
                      'domain': domain,
                      'status': 'web_found',
                      'message': 'Found on company website',
                      'confidence': 'high',
                      'patterns_tried': 0
                  }

              # Step 2: Generate patterns for SMTP verification
              patterns = generate_patterns(first_name, last_name, domain)
              if not patterns:
                  return {**row, 'email': '', 'status': 'no_patterns', 'confidence': 'low'}

              # Step 3: SMTP verification (works for non-catch-all domains)
              print(f"  [STEP 2] SMTP verification...")
              email, status, message = verify_patterns(patterns, domain)

              confidence = 'high' if status == 'verified' else ('medium' if status in ['catchall', 'unverifiable'] else 'low')

              return {
                  **row,
                  'email': email or '',
                  'domain': domain,
                  'status': status,
                  'message': message,
                  'confidence': confidence,
                  'patterns_tried': len(patterns)
              }

          # Main execution
          print(f"Starting email verification at {datetime.now()}")

          # Read input CSV
          input_file = 'input.csv'
          output_file = 'verified_emails.csv'

          try:
              with open(input_file, 'r') as f:
                  reader = csv.DictReader(f)
                  contacts = list(reader)
          except FileNotFoundError:
              print("No input.csv found. Creating sample...")
              contacts = [
                  {'First Name': 'Thomas', 'Last Name': 'Graham', 'Company': 'Dolby'},
              ]

          print(f"Processing {len(contacts)} contacts...")

          results = []
          for i, contact in enumerate(contacts):
              print(f"[{i+1}/{len(contacts)}] {contact.get('First Name', '')} {contact.get('Last Name', '')} @ {contact.get('Company', '')}")
              result = process_contact(contact)
              results.append(result)
              print(f"  -> {result.get('email', 'N/A')} ({result.get('confidence', 'N/A')})")

          # Write output
          if results:
              fieldnames = list(results[0].keys())
              with open(output_file, 'w', newline='') as f:
                  writer = csv.DictWriter(f, fieldnames=fieldnames)
                  writer.writeheader()
                  writer.writerows(results)

          # Summary
          verified = sum(1 for r in results if r.get('confidence') == 'high')
          found = sum(1 for r in results if r.get('email'))
          print(f"\nComplete! {found} emails found, {verified} verified")
          print(f"Results saved to {output_file}")

          PYTHON_SCRIPT

      - name: Upload results
        uses: actions/upload-artifact@v4
        with:
          name: verified-emails
          path: verified_emails.csv
          retention-days: 30
